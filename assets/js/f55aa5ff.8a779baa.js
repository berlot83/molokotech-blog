"use strict";(self.webpackChunkmolokotech_ui=self.webpackChunkmolokotech_ui||[]).push([[8676],{1888:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"anonymous-clases","metadata":{"permalink":"/java-blog/anonymous-clases","source":"@site/java-blog/2024-10-11-anonymous-class/2024-10-11-anonymous-class.md","title":"Anonymous Classes","description":"banner","date":"2024-10-11T00:00:00.000Z","tags":[{"inline":true,"label":"java","permalink":"/java-blog/../tags.yml/java"},{"inline":true,"label":"spring-boot","permalink":"/java-blog/../tags.yml/spring-boot"}],"readingTime":1.865,"hasTruncateMarker":true,"authors":[{"name":"Axel Berlot","title":"Java developer @ Opendev Pro","url":"http://web.molokotech.com/?lang=en","email":"berlot83@yahoo.com.ar","page":{"permalink":"/java-blog/authors/axel"},"socials":{"github":"https://github.com/berlot83","x":"https://x.com/Singleton","linkedin":"https://www.linkedin.com/in/axelberlot/","newsletter":"http://web.molokotech.com/?lang=en"},"imageURL":"https://avatars.githubusercontent.com/u/22393878?s=96&v=4","key":"axel"}],"frontMatter":{"slug":"anonymous-clases","title":"Anonymous Classes","authors":["axel"],"tags":["java","spring-boot"]},"unlisted":false,"nextItem":{"title":"Interfaces","permalink":"/java-blog/Interfaces"}},"content":"![banner](./../../static/img/banner-java.jpg)\\r\\n\\r\\n[sandbox.molokotech.com](https://docusaurus.io/docs/blog) are powered by the [Molokotech](http://web.molokotech.com/?lang=en).\\r\\n\\r\\nLas clases an\xf3nimas son s\xf3lo objetos que se instancian en funci\xf3n a una interface, una clase abstracta o una clase concreta que permite definir una clase conreta dentro de una instancia y s\xf3lo dentro de la misma, de esta forma no es necesario crear toda una clase nueva para un comportamiento custom.\\r\\n\\r\\n#### Ejemplo\\r\\n* Abajo una clase an\xf3nima en funci\xf3n de Car que retorna un String\\r\\n* Debajo una clase que hereda la clase Car.\\r\\n\\r\\n~~~java\\r\\nimport java.time.LocalDateTime;\\r\\n\\r\\npublic class CustomCar {\\r\\n\\tpublic static void main(String[] args) {\\r\\n\\t\\t// We define a custom class from another one that only going to live inside myCustomCar \\r\\n\\t\\tString messageFromCustomCar = new Car() {\\r\\n\\t\\t\\t\\r\\n\\t\\t\\t// Custom attribute\\r\\n\\t\\t\\tString brand = \\"Chevrolet\\";\\r\\n\\t\\t\\t\\r\\n\\t\\t\\t// This method is useless but it is needed to override\\r\\n\\t\\t\\t@Override\\r\\n\\t\\t\\tvoid startedTime() {\\r\\n\\t\\t\\t\\tSystem.out.println(\\"started ON second: \\" + LocalDateTime.now().getSecond());\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t\\r\\n\\t\\t\\t// Custom method\\r\\n\\t\\t\\tString getMessage() {\\r\\n\\t\\t\\t\\treturn \\"Do you like my \\" + brand + \\" custom Car?\\";\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t\\r\\n\\t\\t}.getMessage();\\r\\n\\t\\t\\r\\n\\t\\t// We only print getMessage()\\r\\n\\t\\tSystem.out.println(messageFromCustomCar);\\r\\n\\t\\t\\r\\n\\t}\\r\\n}\\r\\n\\r\\n// Classic extension \\r\\nclass Peugeot extends Car {\\r\\n\\t@Override\\r\\n\\tvoid startedTime() {\\r\\n\\t\\tSystem.out.println(\\"Started ON pretty fast\\");\\r\\n\\t}\\r\\n}\\r\\n\\r\\n// Could be an Interface, a concrete class or an abstract class\\r\\nabstract class Car {\\r\\n\\tabstract void startedTime();\\r\\n}\\r\\n~~~\\r\\n\\r\\n#### Cu\xe1ndo y d\xf3nde utilizarla\\r\\n1) Utilizar una definici\xf3n en un punto en particular para no tener que definir toda una clase completa para evitar tener clases definidas que no vas a reutilizar.\\r\\n2) Tener exactamente la implementaci\xf3n justo donde se use por ejemplo en aquellos par\xe1metros que son interfaces.\\r\\n3) Acceder a miembros de la clase que existen en la clase custom.\\r\\n\\r\\n~~~java\\r\\n\\r\\npublic class CustomCar {\\r\\n\\t\\r\\n\\tpublic static void main(String[] args) {\\r\\n\\t\\t// In this case Runnable is an Interface\\r\\n\\t\\tnew Thread(new Runnable() {\\r\\n\\t\\t\\t@Override\\r\\n\\t\\t\\tpublic void run() {\\r\\n\\t\\t\\t\\tSystem.out.println(\\"Just in the exact place\\");\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\r\\n\\t}\\r\\n\\t\\r\\n}\\r\\n\\r\\n~~~\\r\\n\\r\\n:::tip\\r\\nHoy en d\xeda se utilizan menos las clases an\xf3nimas ya que aprarecieron las expresiones lambda, sin embargo las mismas tienen la desventaja que s\xf3lo pueden ser definidas si:\\r\\n1) De donde se crean es una interface.\\r\\n2) Si s\xf3lo tiene un m\xe9todo abstracto que no sea los que vienen de la clase Object.\\r\\n:::\\r\\n\\r\\n\\r\\n\x3c!-- truncate --\x3e"},{"id":"Interfaces","metadata":{"permalink":"/java-blog/Interfaces","source":"@site/java-blog/2024-10-11-interfaces/2024-10-11-interfaces.md","title":"Interfaces","description":"banner","date":"2024-10-11T00:00:00.000Z","tags":[{"inline":true,"label":"molokotech","permalink":"/java-blog/../tags.yml/molokotech"}],"readingTime":3.06,"hasTruncateMarker":true,"authors":[{"name":"Axel Berlot","title":"Java developer @ Opendev Pro","url":"http://web.molokotech.com/?lang=en","email":"berlot83@yahoo.com.ar","page":{"permalink":"/java-blog/authors/axel"},"socials":{"github":"https://github.com/berlot83","x":"https://x.com/Singleton","linkedin":"https://www.linkedin.com/in/axelberlot/","newsletter":"http://web.molokotech.com/?lang=en"},"imageURL":"https://avatars.githubusercontent.com/u/22393878?s=96&v=4","key":"axel"}],"frontMatter":{"slug":"Interfaces","title":"Interfaces","authors":"axel","tags":["molokotech"]},"unlisted":false,"prevItem":{"title":"Anonymous Classes","permalink":"/java-blog/anonymous-clases"},"nextItem":{"title":"Autoboxing and Unboxing","permalink":"/java-blog/autoboxing-unboxing"}},"content":"![banner](./../../static/img/banner-java.jpg)\\r\\n\\r\\n[sandbox.molokotech.com](https://docusaurus.io/docs/blog) are powered by the [Molokotech](http://web.molokotech.com/?lang=en).\\r\\n\\r\\n#### Caracter\xedsticas:\\r\\n* Todos sus m\xe9todos son p\xfablicos por defecto, pero luego de java 9 en adelante los mismos pueden ser definidos privados con body definido.\\r\\n* Pueden contener atributos y m\xe9todos.\\r\\n* Pueden extender de otras interfaces.\\r\\n* Pueden todos sus atributos son abstractos.\\r\\n* Sus atributos son finales por definici\xf3n.\\r\\n* Pueden contener atributos y m\xe9todos est\xe1ticos.\\r\\n* Desde Java 8 en adelante pueden contener uno o m\xe1s m\xe9todos default.\\r\\n\\r\\n#### Ventajas:\\r\\n* Las interfaces nos permiten definir contratos, que luego son implementados en una clase concreta.\\r\\n* Las interfaces nos permiten aplicar con flexibilidad la abstracci\xf3n y el polimorfismo.\\r\\n* Una Clase puede implementar m\xfaltiples interfaces que a diferencia de herencia entre clases que s\xf3lo se puede heredar de una clase.\\r\\n* Las interfaces pueden ayudarnos a tener un c\xf3digo m\xe1s resumido con el uso de expresiones lambda.\\r\\n* En funci\xf3n a interfaces pueden crearse instancias de clases an\xf3nimas para no depender de una implementaci\xf3n o clase particular previamente definida.\\r\\n\\r\\n~~~java\\r\\n// Concrete implementation\\r\\npublic class HiloConcreto implements Startable {\\r\\n\\r\\n\\t@Override\\r\\n\\tpublic void start() {\\r\\n\\t\\tSystem.out.println(\\"HiloConcreto started\\");\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\n// Anonymous class\\r\\nclass MainAnonymous {\\r\\n\\tpublic static void main(String[] args) {\\r\\n\\t\\tStartable s = new Startable() {\\r\\n\\t\\t\\t\\r\\n\\t\\t\\t@Override\\r\\n\\t\\t\\tpublic void start() {\\r\\n\\t\\t\\t\\tSystem.out.println(\\"Main started into anonymous class!!!\\");\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t};\\r\\n\\t\\ts.start();\\r\\n\\t}\\r\\n}\\r\\n\\r\\n// Lambda expression\\r\\nclass MainLambdaExpression {\\r\\n\\tpublic static void main(String[] args) {\\r\\n\\t\\tStartable s = () -> System.out.println(\\"Main started into lambda expression!!!\\");\\r\\n\\t \\ts.start();\\r\\n\\t}\\r\\n}\\r\\n\\r\\ninterface Startable {\\r\\n\\tvoid start();\\r\\n}\\r\\n~~~\\r\\n\\r\\n\\r\\n#### Caracter\xedsitcas de sus miembros:\\r\\n* Los atributos son p\xfablic, est\xe1ticos y finales siempre.\\r\\n* Los m\xe9todos pueden ser p\xfablicos por defecto o privados.\\r\\n* Los m\xe9todos pueden ser abstractos o croncretos.\\r\\n* Los m\xe9todos cuando son abstractos no pueden ser est\xe1tico y vecebersa.\\r\\n* El uso de un m\xe9todo default tiene sentido cuando en las implementaci\xf3nes no se sobreescribe el mismo.\\r\\n* Las insterfaces pueden definir m\xfaltiples m\xe9todos default.\\r\\n* Pueden definir m\xfaltiples m\xe9todos privados.\\r\\n* El uso de m\xe9todos privados tiene sentido cuando internamente en la misma interface se invocan m\xe9todos.\\r\\n* Como cualquier acceso est\xe1tico se puede prescindir del nombre de la clase, a menos que exista una variable definida en el mismo m\xe9todo con lo cual el compilador prioriza la variable local y deja de apuntar a la est\xe1tica. \\r\\n\\r\\n#### Ejemplo pr\xe1ctico de cada uso\\r\\n\\r\\nEl siguiente es un ejercicio, donde se trata de explicar c\xf3mo se pueden usar los miembros de la interface en forma pr\xe1ctica.\\r\\n\\r\\n~~~java\\r\\npublic interface Streamable {\\r\\n\\r\\n\\t/**\\r\\n\\t * \\t\\tAttributes -> only public\\r\\n\\t */\\r\\n\\r\\n\\t// implicitly public static and final\\r\\n\\tString letters = \\"abc\\";\\r\\n\\t// Redundant static and access modifier\\r\\n\\tpublic static String numbers = \\"123\\";\\r\\n\\r\\n\\t/**\\r\\n\\t * \\t\\tMethods -> can be public or private\\r\\n\\t */\\r\\n\\r\\n\\t// implicitly public and abstract\\r\\n\\tvoid stream();\\r\\n\\r\\n\\t// Redundant abstract and access modifier\\r\\n\\tpublic abstract void streamRedundant();\\r\\n\\r\\n\\t// Must\'ve a body too\\r\\n\\tprivate void privateInstanceLetterMethod() {\\r\\n\\t\\tletters = letters + \\"def\\"; \\t// this will not compile!!!\\r\\n\\t\\tSystem.out.println(Streamable.letters);\\r\\n\\t}\\r\\n\\r\\n\\t// Belongs to the instance when the implementation did not override this one\\r\\n\\tdefault void defaultLettersBehaivor() {\\r\\n\\t\\tprivateInstanceLetterMethod();\\r\\n\\t}\\r\\n\\t\\r\\n\\t// Belongs to the instance when the implementation did not override this one\\r\\n\\tdefault void defaultNumbersBehaivor() {\\r\\n\\t\\tStreamable.privatEstaticMethod(\\"678\\");\\r\\n\\t}\\r\\n\\r\\n\\t// Belongs to the class and must\'ve a body too\\r\\n\\tprivate static void privatEstaticMethod(String numbers) {\\r\\n\\t\\tnumbers = numbers + \\"456\\";\\t// this will compile OK!!!\\r\\n\\t\\tSystem.out.println(Streamable.numbers);\\r\\n\\t}\\r\\n\\r\\n}\\r\\n~~~\\r\\n\\r\\n:::tip\\r\\nDesde Java 8 en adelante se habilit\xf3 el uso de expresiones lambda ampliamente utilizadas en programaci\xf3n funcional, la que mejora notablemente la lectura del c\xf3digo y limita la cantidad de l\xedneas de c\xf3digo haciendo una lectura de los c\xf3digos fuente m\xe1s legible.\\r\\n:::\\r\\n\\r\\n\x3c!-- truncate --\x3e"},{"id":"autoboxing-unboxing","metadata":{"permalink":"/java-blog/autoboxing-unboxing","source":"@site/java-blog/2024-07-28-autoboxing-unboxing/2024-07-28-autoboxing-unboxing.md","title":"Autoboxing and Unboxing","description":"banner","date":"2024-07-28T00:00:00.000Z","tags":[{"inline":true,"label":"molokotech","permalink":"/java-blog/../tags.yml/molokotech"}],"readingTime":2.145,"hasTruncateMarker":true,"authors":[{"name":"Axel Berlot","title":"Java developer @ Opendev Pro","url":"http://web.molokotech.com/?lang=en","email":"berlot83@yahoo.com.ar","page":{"permalink":"/java-blog/authors/axel"},"socials":{"github":"https://github.com/berlot83","x":"https://x.com/Singleton","linkedin":"https://www.linkedin.com/in/axelberlot/","newsletter":"http://web.molokotech.com/?lang=en"},"imageURL":"https://avatars.githubusercontent.com/u/22393878?s=96&v=4","key":"axel"}],"frontMatter":{"slug":"autoboxing-unboxing","title":"Autoboxing and Unboxing","authors":["axel"],"tags":["molokotech"]},"unlisted":false,"prevItem":{"title":"Interfaces","permalink":"/java-blog/Interfaces"},"nextItem":{"title":"Access modifiers","permalink":"/java-blog/access-modifiers"}},"content":"![banner](./../../static/img/banner-java.jpg)\\n\\n**Autoboxing** is the conversion from a **primitive** value to a **Wrapper** Classes.\\nIt is a background operation outside from de programmer control, that transform primitive types creating objects without explicity creating in the code.\\n\\n__The simplest way__:<br/>\\n`Integer i = 1;`\\n\\n From behind the scenes compiler run new Integer(1) although the IDE says it\'s deprecated when you type it, the intention is to write cleaner code.\\n\\n__It runs when__:<br/>\\n1) Passed as a parameter to a method that expects a value of the corresponding object wrapper type.\\n2) Assigned to a variable of the corresponding object wrapper type.\\n\\n```java\\npackage com.molokotech.models;\\n\\npublic class Autoboxing {\\n\\t\\n\\t// Assigned to a variable\\n\\tvoid number() {\\n\\t\\tint number = 100;\\n\\t\\tInteger num = number;\\t// The compiler converts from int to new Integer\\n\\t}\\n\\n\\t// Passed as a parameter\\n\\tvoid iterate() {\\n\\t\\tList<Integer> li = new ArrayList<>();\\n\\t\\tfor (int i = 1; i < 50; i)\\n\\t\\t    li.add(i);\\t// The compiler converts from int to new Integer\\n\\t}\\n\\n\\t// Simplest examples\\n\\tvoid autoboxing() {\\n\\t\\tCharacter c = \'c\';\\t// char to new Character\\n\\t\\tInteger i = 1;\\t\\t// int to new Integer\\n\\t}\\n\\n\\t/* remainder (%) and unary plus (+=) operators does\'nt works with:\\n\\t\\tInteger\\n\\t\\tByte\\n\\t\\tShort\\n\\tOnly primitive types are allowed for this operators so from behind the scenes always invokes i.intValue() */\\n\\tpublic int sum(List<Byte> li) {\\n\\t\\tint sum = 0;\\n\\t\\tfor (Byte i : li)\\n\\t\\t\\tif (i % 2 == 0)\\n\\t\\t\\t\\tsum += i;\\n\\t\\t\\treturn sum;\\n\\t}\\n\\n}\\n```\\n\\n![autoboxing](autoboxing.png)\\n\\n**Unboxing** is the conversion from an **Object** to a **primitive** value.\\n\\n__The simplest way__:<br/>\\n`Integer number = 100; int num = number;`\\n\\n1) Passed as a parameter to a method that expects a value of the corresponding primitive type.\\n2) Assigned to a variable of the corresponding primitive type.\\n\\n```java\\npackage com.molokotech.models;\\n\\npublic class Unboxing {\\n\\t\\n\\t// Assigned to a variable\\n\\tvoid number() {\\n\\t\\tInteger number = 100;\\n\\t\\tint num = number; \\t// The compiler convertes from Integer to int\\n\\t}\\n\\n\\t// Passed as a parameter\\n\\tvoid iterate() {\\n\\t\\tint[] li = new int[50];\\n\\t\\tfor (Integer i = 1; i < 50; i += 2)\\n\\t\\t\\tli[i] = i;\\n\\t}\\n\\n}\\n```\\n\\n![unboxing](unboxing.png)\\n\\nJava compiler run the background operation with for **autoboxing** and **unboxing** on the corresponding wrapper clases:\\n\\n| Primitive type | Wrapper class |\\n|----------------|---------------|\\n| boolean    \\t | Boolean       |\\n| byte    \\t \\t | Byte       \\t |\\n| char    \\t \\t | Character     |\\n| float    \\t \\t | Float       \\t |\\n| int    \\t \\t | Integer       |\\n| long    \\t \\t | Long       \\t |\\n| short    \\t \\t | Short       \\t |\\n| double    \\t | Double        |\\n\\n\x3c!-- truncate --\x3e"},{"id":"access-modifiers","metadata":{"permalink":"/java-blog/access-modifiers","source":"@site/java-blog/2024-07-27-access-modifiers/2024-07-27-access-modifiers.md","title":"Access modifiers","description":"banner","date":"2024-07-27T00:00:00.000Z","tags":[{"inline":true,"label":"molokotech","permalink":"/java-blog/../tags.yml/molokotech"}],"readingTime":2.005,"hasTruncateMarker":true,"authors":[{"name":"Axel Berlot","title":"Java developer @ Opendev Pro","url":"http://web.molokotech.com/?lang=en","email":"berlot83@yahoo.com.ar","page":{"permalink":"/java-blog/authors/axel"},"socials":{"github":"https://github.com/berlot83","x":"https://x.com/Singleton","linkedin":"https://www.linkedin.com/in/axelberlot/","newsletter":"http://web.molokotech.com/?lang=en"},"imageURL":"https://avatars.githubusercontent.com/u/22393878?s=96&v=4","key":"axel"}],"frontMatter":{"slug":"access-modifiers","title":"Access modifiers","authors":["axel"],"tags":["molokotech"]},"unlisted":false,"prevItem":{"title":"Autoboxing and Unboxing","permalink":"/java-blog/autoboxing-unboxing"},"nextItem":{"title":"Data Types","permalink":"/java-blog/Java"}},"content":"![banner](./../../static/img/banner-java.jpg)\\r\\n\\r\\nAccess modifiers are implemented in java with four levels of abtraction.\\r\\n\\r\\n**Improves**:\\r\\n* Security\\r\\n* Cleaner code\\r\\n* Scalability\\r\\n* Readability\\r\\n\\r\\n__They are aplicable to__:\\r\\n1) Classes \u2192 <font color=\\"blue\\">*public*</font> | <font color=\\"violet\\">*default*</font>\\r\\n2) Interfaces \u2192 <font color=\\"blue\\">*public*</font> | <font color=\\"violet\\">*default*</font>\\r\\n3) Constructors \u2192 <font color=\\"blue\\">*public*</font> | <font color=\\"violet\\">*default*</font> | <font color=\\"grey\\">*protected*</font> | <font color=\\"red\\">*private*</font>\\r\\n4) Class member attributes and methods \u2192 <font color=\\"blue\\">*public*</font> | <font color=\\"violet\\">*default*</font> | <font color=\\"grey\\">*protected*</font> | <font color=\\"red\\">*private*</font>\\r\\n5) Interface member attributes and methods \u2192 <font color=\\"blue\\">*public*</font> | <font color=\\"red\\">*private*</font>\\r\\n\\r\\n**Level of visibility**:\\r\\n* <font color=\\"blue\\">public</font> \u2192 could be access from every pacakge\\r\\n* <font color=\\"violet\\">default</font> \u2192 inside the same package only (*no keyword*)\\r\\n* <font color=\\"grey\\">protected</font> \u2192 access from the same package and their sub classes\\r\\n* <font color=\\"red\\">private</font> \u2192 only inside the class \\r\\n\\r\\n**Default** \u2192 *refers at no reserve keyword just, it isn\'t the keyword of the example bellow because this refers to the type of member method*\\r\\n\\r\\n**Classes** and **Interfaces** could be **public** or **default** (*no keyword*).\\r\\n\\r\\n`Interfaces cannot have members with default or protected access modifiers, please remember that the default modifier it\'s not the keyword.`\\r\\n\\r\\n**Real life example for access modifiers in an interface**:\\r\\n\\r\\n```java\\r\\npackage com.molokotech.interfaces;\\r\\n\\r\\n// Accesible from any package\\r\\npublic interface Loggueable {\\r\\n\\tvoid log(); // implicitly public by default write public does not affect\\r\\n\\t\\r\\n\\t// private access modifier allowed but should have body\\r\\n\\tprivate String colorConsole(String color) {\\r\\n\\t\\tswitch(color) {\\r\\n\\t\\tcase \\"yellow\\":\\r\\n\\t\\t\\treturn \\"WARN\\";\\r\\n\\t\\tcase \\"red\\":\\r\\n\\t\\t\\treturn \\"ERROR\\";\\r\\n\\t\\tcase \\"blue\\":\\r\\n\\t\\t\\treturn \\"INFO\\";\\r\\n\\t\\tdefault: \\r\\n\\t\\t\\treturn \\"INFO\\";\\r\\n\\t\\t}\\r\\n\\t};\\r\\n\\r\\n\\t/* default methods cannot be private are always public or implicity public\\r\\n\\t   every instance implementation should be access to it */ \\r\\n\\tdefault void labelColor(String color) {\\r\\n\\t\\tcolorConsole(color);\\r\\n\\t}\\r\\n}\\r\\n\\r\\n// Accesible with in the same package\\r\\ninterface AnotherLoggeable {\\r\\n\\t\\r\\n}\\r\\n```\\r\\n\\r\\nMember **attributes** and **methods** on the class can carry all types of modifiers. \\r\\n\\r\\n```java\\r\\npublic class AccessModifiers {\\r\\n\\t\\r\\n\\tpublic int n1;\\r\\n\\tprotected int n2;\\r\\n\\tint n3;\\r\\n\\tprivate int n4;\\t// accesible only somewhere inside the class\\r\\n\\r\\n\\tpublic static void main(String[] args) {\\r\\n\\t\\tSystem.out.println(\\"HOLA\\");\\r\\n\\t}\\r\\n\\r\\n\\tpublic AccessModifiers() {\\r\\n\\r\\n\\t}\\r\\n}\\r\\n\\r\\nclass Protected {\\r\\n\\tprotected Protected() {\\r\\n\\t\\tnew Private(); // this NOT COMPILE at all! cannot access to the constructor outside the class\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\nclass Default {\\r\\n\\tDefault() {\\r\\n\\t\\tnew Protected();\\r\\n\\t}\\r\\n}\\r\\n\\r\\nclass Private {\\r\\n\\tprivate Private() {\\r\\n\\t\\tnew Default();\\r\\n\\t}\\r\\n}\\r\\n```\\r\\n\\r\\nIt is important to note that some modifiers affects the overriding behavor.\\r\\n\\r\\n\x3c!-- truncate --\x3e"},{"id":"Java","metadata":{"permalink":"/java-blog/Java","source":"@site/java-blog/2024-07-27-data-types/2024-07-27-data-types.md","title":"Data Types","description":"banner","date":"2024-07-27T00:00:00.000Z","tags":[{"inline":true,"label":"molokotech","permalink":"/java-blog/../tags.yml/molokotech"},{"inline":true,"label":"java","permalink":"/java-blog/../tags.yml/java"}],"readingTime":4.345,"hasTruncateMarker":true,"authors":[{"name":"Axel Berlot","title":"Java developer @ Opendev Pro","url":"http://web.molokotech.com/?lang=en","email":"berlot83@yahoo.com.ar","page":{"permalink":"/java-blog/authors/axel"},"socials":{"github":"https://github.com/berlot83","x":"https://x.com/Singleton","linkedin":"https://www.linkedin.com/in/axelberlot/","newsletter":"http://web.molokotech.com/?lang=en"},"imageURL":"https://avatars.githubusercontent.com/u/22393878?s=96&v=4","key":"axel"}],"frontMatter":{"slug":"Java","title":"Data Types","authors":["axel"],"tags":["molokotech","java"]},"unlisted":false,"prevItem":{"title":"Access modifiers","permalink":"/java-blog/access-modifiers"}},"content":"![banner](./../../static/img/banner-java.jpg)\\r\\n\\r\\n[sandbox.molokotech.com](https://docusaurus.io/docs/blog) are powered by the [Molokotech](http://web.molokotech.com/?lang=en).\\r\\n\\r\\n\\r\\nJava has an strong dependency with data types, it is important to understand how they works and how to use it.\\r\\n\\r\\nHave you ever tougth why there are so many data types from different sizes? it\'s really easy to explain, just because when Java was created sitting on 1995 and years later, the devices were Java could installed were pretty small in memory, so the aproach to used only data types that reserves less memory was important.\\r\\n\\r\\nToday no one is concerned by this because your **phone** today is **faster** and **bigger** about memory speaking than your computers.\\r\\n\\r\\nToday it\'s not a problem if you choose to use a **byte** or an **int** because it does\'nt have side effects on the devices.\\r\\n\\r\\nData Types in **Java**.\\r\\n\\r\\n```java\\r\\npackage com.molokotech.models;\\r\\n\\r\\npublic class DataTypes {\\r\\n    private int num = 1;                // Integer wrapper Class\\r\\n    private boolean isBigger = true;\\t// Boolean wrapper Class\\r\\n    private char ch = \'j\';              // Character wrapper Class\\r\\n    private float f = 100;              // Float wrapper Class cast needed 100f/100F\\r\\n    private long l = 5000;              // Long wrapper Class cast needed 5000l/5000L\\r\\n    private short sh = 1234;            // Short wrapper Class\\r\\n    private byte b = 0;\\t                // Byte wrapper Class\\r\\n    \\r\\n    // private vars can access to methods from the same class\\r\\n    private void getDataType() {\\r\\n        System.out.println(\\"primitive type \\" + this.num + \\" in Java is the default for all non decimal numbers\\");\\r\\n        System.out.println(\\"primitive type \\" + this.isBigger + \\" default value is false\\");\\r\\n        System.out.println(\\"primitive type \\" + this.ch + \\" should be rounded by simple quotes default value 0 or u0000, character/letter\\");\\r\\n        System.out.println(\\"primitive type \\" + this.f + \\" it\'s used by default like int default value 0.0\\");\\r\\n        System.out.println(\\"primitive type \\" + this.l);\\r\\n        System.out.println(\\"primitive type \\" + this.sh);\\r\\n        System.out.println(\\"primitive type \\" + this.b + \\" values from -128/127\\");\\r\\n    }\\r\\n    \\r\\n    // getDataType() should be called only from this class\\r\\n    public static void main(String[] args) {\\r\\n\\t\\tnew DataTypes().getDataType();\\r\\n\\t}\\r\\n}\\r\\n```\\r\\n\\r\\n![result](./image1.png)\\r\\n\\r\\n**Wrapper** classes <font color=\\"red\\">Float</font> and <font color=\\"red\\">Long</font> shoud be casted when declared until it reference another variable, in this momment compile apply **autoboxing** strategy.\\r\\n\\r\\n```java\\r\\npackage com.molokotech.models;\\r\\n\\r\\npublic class Cast {\\r\\n\\t\\r\\n    private float f = 100;\\t// Float wrapper Class cast needed 100f/100F\\r\\n    private long l = 5000;\\t// Long wrapper Class cast needed 5000l/5000L\\r\\n\\r\\n    private void doCast() {\\r\\n    \\tFloat sh = 123f;\\t// must be casted -> Float sh = 123; not compile!!\\r\\n    \\tFloat shRef = this.f;   // Autoboxing when ref another variable not casting needed\\r\\n    \\t\\r\\n    \\tLong l = 123l; \\t\\t// must be casted -> Long l = 123; not compile!!\\r\\n    \\tLong lref = this.l; \\t// Autoboxing when ref another variable not casting needed\\r\\n    }\\r\\n\\t\\r\\n}\\r\\n```\\r\\nThere three rules:\\r\\n1) Every **number** data-types **non-decimal** is treated as an **int** always unless it is explicitly cast.\\r\\n2) Every **number** data-types decimal es treated as an double always unless it is explicitly cast.\\r\\n3) Cannot do reference from a smaller data-type to a bigger data-type, because it does\'nt fit, unless it is casted, in that case the value will try to fit passing maximun values.\\r\\n\\r\\nThe next image it\'s not absolute and is just note the different sizes between data types in a graphical way.\\r\\n\\r\\n![result](./datatypes-java.drawio.png)\\r\\n\\r\\nThis code has some **COMPILATION PROBLEMS** related to bigger data-types trying to fit in smaller or incompatible data-types and other valid code you should copy into your IDE and make an analize it.\\r\\n\\r\\n```java\\r\\n\\r\\npackage com.molokotech.utils;\\r\\n\\r\\npublic class ReferenceMemory {\\r\\n    \\r\\n\\tvoid referenceMemoryPoints() {\\r\\n    \\tint num1 = 1000;\\r\\n    \\tInteger num2 = num1; // autoboxing compile\\r\\n    \\t\\r\\n    \\tbyte num3 = 123;\\r\\n    \\tInteger num4 = num3; // compiler knows that a byte is not an Integer -> not compile\\r\\n    \\t\\r\\n    \\tbyte num5 = 123;\\r\\n    \\tint num6 = num5; // num5 primitive treated as an int, fit as an int -> compile\\r\\n    \\t\\r\\n    \\tshort num7 = 1234;\\r\\n    \\tint num8 = num7; // num6 primitive treated as an int, fit as an int -> compile\\r\\n    \\t\\r\\n    \\tint num9 = 123;\\r\\n    \\tbyte num10 = num9; // num9 does\'nt fit in a byte because is bigger unless be casted -> not compile\\r\\n    \\t\\r\\n    \\tint num11 = 123;\\r\\n    \\tbyte num12 = (byte) num11; // num11 does\'nt fit in a byte because is bigger but is explicitly casted -> compile\\r\\n    \\t\\r\\n    \\tlong num13 = 12000;\\r\\n    \\tInteger num14 = num13; // compiler knows that a long is not an Integer -> not compile\\r\\n    \\t\\r\\n    \\tlong num15 = 13000;\\r\\n    \\tInteger num16 = (int) num13; // long is not an Integer but just casted -> compile\\r\\n    \\t\\r\\n    \\tlong num17 = 900000000033333l;\\r\\n    \\tint num18 = num17; // long cannot fit into an Integer -> not compile\\r\\n    \\t\\r\\n    \\tlong num19 = 900000000033333l;\\r\\n    \\tint num20 = (int) num19; // cannot fit but cast exced limits of the datatype -> compile\\r\\n    \\t\\r\\n    \\tint num21 = 2000;\\r\\n    \\tbyte num22 = (byte) num21;\\r\\n    \\tSystem.out.println(num22); // cannot fit but cast exced limits of the datatype -> compile\\r\\n    }\\r\\n\\t\\r\\n}\\r\\n```\\r\\n\\r\\nViewing the results in the IDE\\r\\n\\r\\n![result](./data-types-ref.png)\\r\\n\\r\\nIf we comment the compilation problems and run the program we see that prints a negative number even if we assign a positive number, this is because it reach out the max size of data-type and force it to assign with the cast, so it tries to fit anyway passing the limits.\\r\\n\\r\\n![max](data-types-max.png)\\r\\n\\r\\n\x3c!-- truncate --\x3e"}]}}')}}]);